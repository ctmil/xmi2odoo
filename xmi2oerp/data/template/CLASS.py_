# -*- coding: utf-8 -*-
${LICENSE_HEADER}
{% def model(s='.') %}${CLASS.oerp_id(s, False)}{% end %}\
{% def emodel(s='.') %}${CLASS.oerp_id(s)}{% end %}\

import re
import netsvc
from osv import osv, fields

class ${CLASS.name}(osv.osv):
    """${CLASS.get('documentation', '')}"""
    _name = '${emodel()}'
{%  if not CLASS.is_extended() %}\
    _description = '${CLASS.get('documentation',CLASS.name)[:64]}'
{%  end %}\
{%  if len(CLASS.child_of)>0 %}\
    _inherits = { ${','.join(['\'%s\':\'%s_id\'' % (parent.oerp_id('.'), parent.oerp_id('_')) for parent in CLASS.parents(not_stereotypes=['prototype','extend']) ])} }
    _inherit = [ ${','.join(['\'%s\'' % (parent.oerp_id('.'),) for parent in CLASS.parents(stereotypes=['prototype','extend'])])} ]
{%  end %}\

{%  for op in CLASS_PRIVATE_OPERATIONS %}\
    def ${op.name}(self, cr, uid, ids{% for par in op.parameters %}, ${par.name}{% end %}):
        pass

{% end %}\
    _states_ = [
{%     for sm in CLASS.get_statemachines(not_stereotypes=['extend','prototype']) %}\
        # State machine: ${sm.name}
{%      for s in sm.list_ordered_states() %}\
        ('${s.name}','${s['label']}'),
{%      end %}\
{%     end %}\
    ]

{% end %}\
    _columns = {
{%  for parent in CLASS.parents(not_stereotypes=['prototype','extend']) %}\
        '${parent.oerp_id('_')}_id': fields.many2one('${parent.oerp_id('.')}', '${parent.get('label', parent.name)}', ondelete='cascade', required=True, help=u"""${quote(parent.get('documentation',''))}"""),
{%  end %}\
{%  for col in CLASS.all_attributes(parents=False) %}\
{%      def sep() %}{%  def sep() %}, {% end %}{% end %}\
{%      def name(prefix='', suffix='') %}${prefix}${col.name}${suffix}{%end%}\
{%      def string %}{% if 'label' in col.tag %}${sep()}string='${col.tag['label']}'{%end%}{%end%}\
{%      def help %}{% if 'documentation' in col.tag %}${sep()}help=u"""${quote(col.tag['documentation'])}"""{%end%}{%end%}\
{%      def ondelete %}{% if 'ondelete' in col.tag %}${sep()}ondelete=${col.tag['ondelete']}{%end%}{%end%}\
{%      def digits %}{% if 'digits' in col.tag %}${sep()}digits=${col.tag['digits']}{%end%}{%end%}\
{%      def size %}{% if 'size' in col.tag %}${sep()}size=${col.tag['size']}{%end%}{%end%}\
{%      def states %}{% if 'states' in col.tag %}${sep()}states=${col.tag['states']}{%end%}{%end%}\
{%      def context %}{% if 'context' in col.tag %}${sep()}context=${col.tag['context']}{%end%}{%end%}\
{%      def domain %}{% if 'domain' in col.tag %}${sep()}domain=${col.tag['domain']}{%end%}{%end%}\
{%      def on_change %}{% if 'on_change' in col.tag %}${sep()}domain=${col.tag['on_change']}{%end%}{%end%}\
{%      def change_default  %}{% if col.is_stereotype('change_default')  %}${sep()}change_default=True{%end %}{%end%}\
{%      def readonly  %}{% if col.is_stereotype('readonly')  %}${sep()}readonly=True{%end %}{%end%}\
{%      def required  %}{% if col.is_stereotype('required') and not CLASS.is_extended() %}${sep()}required=True{%end %}{%end%}\
{%      def select    %}{% if col.is_stereotype('select')    %}${sep()}select=True{%end   %}{%end%}\
{%      def store     %}{% if col.is_stereotype('store')     %}${sep()}store=True{%end    %}{%end%}\
{%      def translate %}{% if col.is_stereotype('translatable') %}${sep()}translate=True{%end%}{%end%}\
{%      def invisible %}{% if col.is_stereotype('invisible') %}${sep()}invisible=True{%end%}{%end%}\
{%      def groups    %}{% if 'module_groups' in col.tag or 'groups' in col.tag %}${sep()} groups='${','.join([col.tag.get('module_groups',''), col.tag.get('groups','')])}'{%end%}{%end%}\
{%      def options   %}${string()}${change_default()}${help()}${ondelete()}${readonly()}${required()}${size()}${states()}${store()}${translate()}${groups()}${context()}${domain()}${invisible()}${on_change()}${select()}{%end%}\
{%      choose col.datatype.name %}\
        \
{%          when 'Boolean'   %}'${name()}': fields.boolean(${options()}), {% end %}\
{%          when 'Integer'   %}'${name()}': fields.integer(${options()}), {% end %}\
{%          when 'Float'     %}'${name()}': fields.float(${digits()}${options()}), {% end %}\
{%          when 'Char'      %}'${name()}': fields.char(${options()}), {% end %}\
{%          when 'Text'      %}'${name()}': fields.text(${options()}), {% end %}\
{%          when 'Date'      %}'${name()}': fields.date(${options()}), {% end %}\
{%          when 'Datetime'  %}'${name()}': fields.datetime(${options()}), {% end %}\
{%          when 'Binary'    %}'${name()}': fields.binary(${options()}), {% end %}\
{%          when 'HTML'      %}'${name()}': fields.html(${options()}), {% end %}\
{%          otherwise        %}'${name()}': \
{%            choose col.datatype.entityclass %}\
{%            when 'cenumeration' %}fields.selection(${repr([(i.name, i.tag.get('label',i.name)) for i in col.datatype.all_literals()])}, ${options()}), {% end %}\
{%            when 'cclass' %}fields.many2one('${col.datatype.oerp_id()}', ${options()}), {% end %}\
{%            end %}\
{%          end %}\
{%      end %}
{%  end %}\
{%  if list(CLASS.get_statemachines(not_stereotypes=['extend','prototype'])) %}\
        'state': fields.selection(_states_, "State"),
{%  end %}\
{%  for ass in CLASS.all_associations(parents=False) %}\
{%      def sep() %}{%  def sep() %}, {% end %}{% end %}\
{%      def actual_id %}${"%s_id" % CLASS_NAME}{%end%}\
{%      def other_id %}${"%s_id" % ass.participant.name.replace('.','_')}{%end%}\
{%      def name(prefix='', suffix='') %}${prefix}${ass.name if ass.name not in [ None, ''] else other_id() }${suffix}{%end%}\
{%      def oerp_id %}${ass.participant.oerp_id()}{%end%}\
{%      def other_module %}${ass.participant.package.name}{%end%}\
{%      def other_obj %}${ass.participant.name}{%end%}\
{%      def other_name %}${actual_id() if ass.swap[0].name in [None, ''] else ass.swap[0].name}{%end%}\
{%      def relational_obj %}${'%s_%s_rel' % (MODULE_NAME, '_'.join([ e.name or '_' for e in ass.association.ends]))}{%end%}\
{%      def change_default  %}{% if ass.is_stereotype('change_default')  %}${sep()}change_default=True{%end %}{%end%}\
{%      def composite %}{% if ass.aggregation == 'composite' %}${sep()}ondelete='cascade'{%end%}{%end%}\
{%      def mult1 %}{% if (eval(ass.multiplicityrange) or (0,0))[0] > 0 and not ass.is_stereotype('required') %}${sep()}required=True{%end%}{%end%}\
{%      def string %}{% if 'label' in ass.tag %}${sep()}string='${quote(ass.tag['label'])}'{%end%}{%end%}\
{%      def help %}{% if 'documentation' in ass.tag %}${sep()}help=u"""${quote(ass.tag['documentation'])}"""{%end%}{%end%}\
{%      def ondelete %}{% if 'ondelete' in ass.tag %}${sep()}ondelete=${ass.tag['ondelete']}{%end%}{%end%}\
{%      def digits %}{% if 'digits' in ass.tag %}${sep()}digits=${ass.tag['digits']}{%end%}{%end%}\
{%      def size %}{% if 'size' in ass.tag %}${sep()}size=${ass.tag['size']}{%end%}{%end%}\
{%      def states %}{% if 'states' in ass.tag %}${sep()}states=${ass.tag['states']}{%end%}{%end%}\
{%      def context %}{% if 'context' in ass.tag %}${sep()}context=${ass.tag['context']}{%end%}{%end%}\
{%      def domain %}{% if 'domain' in ass.tag %}${sep()}domain=${ass.tag['domain']}{%end%}{%end%}\
{%      def on_change %}{% if 'on_change' in ass.tag %}${sep()}domain=${ass.tag['on_change']}{%end%}{%end%}\
{%      def groups    %}{% if 'module_groups' in ass.tag or 'groups' in ass.tag %}${sep()}groups='${','.join([ass.tag.get('module_groups',''), ass.tag.get('groups','')])}'{%end%}{%end%}\
{%      def readonly  %}{% if ass.is_stereotype('readonly')  %}${sep()}readonly=True{%end %}{%end%}\
{%      def required  %}{% if ass.is_stereotype('required') and not CLASS.is_extended() %}${sep()}required=True{%end %}{%end%}\
{%      def select    %}{% if ass.is_stereotype('select')    %}${sep()}select=True{%end   %}{%end%}\
{%      def store     %}{% if ass.is_stereotype('store')     %}${sep()}store=True{%end    %}{%end%}\
{%      def translate %}{% if ass.is_stereotype('translatable') %}${sep()}translate=True{%end%}{%end%}\
{%      def invisible %}{% if ass.is_stereotype('hidden') %}${sep()}invisible=True{%end%}{%end%}\
{%      def options   %}${string()}${change_default()}${help()}${ondelete()}${readonly()}${required()}${size()}${states()}${store()}${translate()}${groups()}${context()}${domain()}${invisible()}${on_change()}${select()}${composite()}${mult1()}{%end%}\
{%      choose ass.multiplicity %}\
        \
{%          when 'one2one'   %}'${name()}': fields.many2one('${oerp_id()}', ${options()}), {% end %}\
{%          when 'many2one'  %}'${name()}': fields.many2one('${oerp_id()}', ${options()}), {% end %}\
{%          when 'one2many'  %}'${name()}': fields.one2many('${oerp_id()}', '${other_name()}', ${options()}), {% end %}\
{%          when 'many2many' %}'${name()}': fields.many2many('${oerp_id()}', '${relational_obj()}', '${name()}', '${other_name()}', ${options()}), {% end %}\
{%          when 'related'   %}'${name()}': fields.related(
                    ${"'%s'" % "','".join(ass.tag['related_by'].split(','))},
                    ${"'%s'" % ass.tag['related_to']},
                    type='${getattr(getattr(ass.participant.member_by_name(ass.tag["related_to"]), "datatype", None),"oerp_type",getattr(ass.participant.association_by_name(ass.tag["related_to"]), "multiplicity","<Not defined>"))}',
                    relation='${oerp_id()}',
                    ${options()}
                    ),{% end %}\
{%      end %}
{%  end %}\
    }

    _defaults = {
{%  for sm in CLASS.statemachines %}\
        'state': '${','.join([ s.name for s in sm.list_states() if s.is_initial() ])}',
{%  end %}\
{%  for col in CLASS_ATTRIBUTES %}\
{%      if col.tag.get('default') and not col.is_stereotype('context') %}\
        '${col.name}': ${col.tag['default']},
{%      end %}\
{%      if col.is_stereotype('context') %}\
        '${col.name}': lambda self, cr, uid, context=None: context and context.get('${col.name}', ${col.tag.get('default','False')}),
{%      end %}\
{%  end %}\
{%  for ass in CLASS.all_associations(parents=False) %}\
{%      if ass.is_stereotype('context') %}\
        '${ass.name}': lambda self, cr, uid, context=None: context and context.get('${ass.name}', ${ass.tag.get('default','False')}),
{%      end %}\
{%  end %}\
    }

{%  for op in [ op for op in CLASS.iter_over_inhereted_attrs('members') if type(op) is uml.COperation ] %}\
    def ${op.name}(self, cr, uid{% if not 'x_' in op.name %}, ids{% end %}{% for par in [ p for p in op.parameters if p.name != 'return'] %}, ${par.name}{% end %}, context=None):
        """${op.tag.get('documentation','')}"""
{%    if op.member_of.name == CLASS.name %}\
        raise NotImplementedError
{%  end %}\
{%    if op.member_of.name != CLASS.name %}\
        member = getattr(self.pool.get('${op.member_of.oerp_id()}'), '${op.name}')
        return member(cr, uid{% if not 'x_' in op.name %}, ids{% end %}{% for par in [ p for p in op.parameters if p.name != 'return'] %}, ${par.name}{% end %})
{%  end %}\

{%  end %}\
{%  for sm in CLASS.get_statemachines(not_stereotypes=['extend','prototype']) %}\
{%      for state in set([ tra.state_to for tra in sm.middle_transitions() if (not tra.state_from.is_initial() and tra.state_to.is_initial()) or (tra.state_from.is_final() and not tra.state_to.is_final())]) %}\
    def action_wfk_set_${state.name}(self, cr, uid, ids, *args):
        self.write(cr, uid, ids, {'state':'${state.name}'})
        wf_service = netsvc.LocalService("workflow")
        for obj_id in ids:
            wf_service.trg_delete(uid, '${CLASS_MODULE}.${CLASS_NAME}', obj_id, cr)
            wf_service.trg_create(uid, '${CLASS_MODULE}.${CLASS_NAME}', obj_id, cr)
        return True

{%      end %}\
{%  end %}\
{% end %}\

${CLASS.name}()

# vim:expandtab:smartindent:tabstop=4:softtabstop=4:shiftwidth=4:
